# Altera Arria10

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME arria10
}

# Arria10 has TDI -> UNKNOWN0 -> HPS -> FPGA -> TDO

# Alter Max 10 id. What is it for?
if { [info exists UNKNOWN0_TAPID] } {
	set _UNKNOWN0_TAPID $UNKNOWN0_TAPID
} else {
	set _UNKNOWN0_TAPID 0x031830dd
}

jtag newtap $_CHIPNAME unknown0 -irlen 10 -expected-id $_UNKNOWN0_TAPID

# ARM CoreSight Debug Access Port (dap HPS)
if { [info exists DAP_TAPID] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x4ba00477
}

jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_DAP_TAPID

# Subsidiary TAP: fpga (tap)
# See Intel Arria 10 Handbook
# https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/hb/arria-10/a10_handbook.pdf
# Intel Arria 10 SX 660 - 0x02e050dd
if { [info exists FPGA_TAPID] } {
	set _FPGA_TAPID $FPGA_TAPID
} else {
	set _FPGA_TAPID 0x02e050dd
}
jtag newtap $_CHIPNAME.fpga tap -irlen 10 -expected-id $_FPGA_TAPID

set _TARGETNAME $_CHIPNAME.cpu
#
# Cortex-A9 target
#
# Base addresses of cores:
# core 0  -  0x80110000
# core 1  -  0x80112000

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

target create $_TARGETNAME.0 cortex_a -dap $_CHIPNAME.dap \
	-coreid 0 -dbgbase 0x80110000
target create $_TARGETNAME.1 cortex_a -dap $_CHIPNAME.dap \
	-coreid 1 -dbgbase 0x80112000 -defer-examine
target smp $_TARGETNAME.0 $_TARGETNAME.1

# Arria10 helpers

proc arria10_clear_registers { target } {
	echo "Arria10 setup: $target"
	set _OCM_END 0xfffbffff
	reg r0 0
	reg r1 0
	reg r2 0
	reg r3 0
	reg r4 0
	reg r5 0
	reg r6 0
	reg r7 0
	reg r8 0
	reg r9 0
	reg r10 0
	reg r11 $_OCM_END
	reg sp_svc $_OCM_END
	reg lr_svc $_OCM_END
	reg sp_abt $_OCM_END
	reg lr_abt $_OCM_END
	reg sp_und $_OCM_END
	reg lr_und $_OCM_END
}

proc arria10_disable_mmu_and_caches { target } {
	# arm mcr pX op1 CRn CRm op2 value
	echo "Disable MMU and caches"
	# Invalidate caches
	catch {
		$target arm mcr 15 0 7 5 0 0
		$target arm mcr 15 0 7 7 0 0
		# Invalidate all TLBs
		$target arm mcr 15 0 8 5 0 0
		$target arm mcr 15 0 8 6 0 0
		$target arm mcr 15 0 8 7 0 0
		$target arm mcr 15 4 8 3 0 0
		$target arm mcr 15 4 8 7 0 0
		set cp [$target arm mrc 15 0 1 0 0]
		set mask [expr 1 << 29 | 1 << 12 | 1 << 11 | 1 << 2 | 1 << 1 | 1 << 0]
		set cp [expr ($cp & ~$mask)]
		$target arm mcr 15 0 1 0 0 $cp
	}
}

proc bootstrap { fname } {
	global _TARGETNAME

	# To avoid code duplication, let the mini loader
	# configure the RAM. So we need only to prepare the
	# CPU, MMU and caches. Load boot code in to OCRAM
	# and execute it.
	arria10_clear_registers $_TARGETNAME.0
	arria10_disable_mmu_and_caches $_TARGETNAME.0
	# load code to OCRAM
	load_image $fname 0xffe00000
	# start code from OCRAM
	resume 0xffe00000
}

proc bringup { bitstream fname } {
	global _CHIPNAME
	global _TARGETNAME

	# before we can load boot loader on clean system,
	# we should configure FPGA
	svf -tap $_CHIPNAME.fpga.tap $bitstream progress

	targets $_TARGETNAME.0
	halt

	# Now we can start actual boot loader.
	bootstrap $fname
}
