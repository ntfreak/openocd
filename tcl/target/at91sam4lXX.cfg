# script for ATMEL sam4l, a CORTEX-M4 chip
#

source [find target/at91sam4XXX.cfg]
source [find mem_helper.tcl]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam4l 0x00000000 0 1 1 $_TARGETNAME

$_TARGETNAME configure -event reset-deassert-post at91sam4l_reset_deassert_post

proc init_reset { mode } {
    jtag arp_init-reset
    # Before we exit reset, we need to know whether we're coming out to run or to halt
    #
    # Can't access it from the reset-deassert-post, so we store it in
    # a global variable here toread back later
    global at91sam4l_pending_halt
    set at91sam4l_pending_halt 0
    if { 0 == [string compare $mode halt] } {
        set at91sam4l_pending_halt 1
    }
    if { 0 == [string compare $mode init] } {
        set at91sam4l_pending_halt 1;
    }
}

# SAM4L SMAP will hold the CPU in reset if TCK is low when nRESET
# deasserts (see datasheet 42023E-SAM-07/2013 sec 8.11.3).
#
# We need to configure whether we want to run or halt out of reset,
# then instruct the SMAP to let us out of reset
proc at91sam4l_reset_deassert_post {} {
    global at91sam4l_pending_halt

    # Register addresses/masks we need
    set ADDR_DCB_DHCSR	0xE000EDF0
    set BIT_DHCSR_DEBUGKEY [expr 0xA05F << 16]
    set BIT_DHCSR_DEBUGEN [expr 1 << 0]
    set ADDR_DCB_DEMCR 0xE000EDFC
    set BIT_DEMCR_VC_CORERESET [expr 1 << 0]
    set ADDR_SMAP_SCR 0x400A3008
    set BIT_HCR [expr 1 << 1]

    poll on
    sleep 20

    if { $at91sam4l_pending_halt } {
        # Set reset vector catch so we halt when reset releases
        mww $ADDR_DCB_DEMCR [expr [ mrw $ADDR_DCB_DEMCR ] | $BIT_DEMCR_VC_CORERESET ]
        mww $ADDR_DCB_DHCSR [expr $BIT_DHCSR_DEBUGEN | $BIT_DHCSR_DEBUGKEY ]
    }

    # SCR.HCR, release reset
    mww $ADDR_SMAP_SCR $BIT_HCR
}

# Without SRST (wired to N_RESET) SAM4L won't reset cleanly
reset_config srst_only

# SAM4L starts from POR with SYSCLK set to 115kHz RCLOCAL, needs slow JTAG speed
adapter_khz 15
