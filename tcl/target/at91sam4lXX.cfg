# script for ATMEL sam4l, a CORTEX-M4 chip
#

source [find target/at91sam4XXX.cfg]
source [find mem_helper.tcl]

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME at91sam4l 0x00000000 0 1 1 $_TARGETNAME

$_TARGETNAME configure -event reset-deassert-post at91sam4l_reset_deassert_post
$_TARGETNAME configure -event reset-init at91sam4l_reset_init


# JTAG clock speeds - you can override these variables in your own
# config file if these don't work for you

# SLOWSPEED JTAG clock applies for running on 115kHz RCLOCAL
set _SLOWSPEED 15
# _MAXSPEED JTAG clock applies for running on 40MHz derived from RC80M, or similar
set _MAXSPEED 5000

proc init_reset { mode } {
    global using_jtag
    if {$using_jtag} { jtag arp_init-reset; }
    # Before we exit reset, we need to know whether we're coming out to run or to halt
    #
    # Can't access it from the reset-deassert-post, so we store it in
    # a global variable here toread back later
    global at91sam4l_pending_halt
    set at91sam4l_pending_halt 0
    if { 0 == [string compare $mode halt] } {
        set at91sam4l_pending_halt 1
    }
    if { 0 == [string compare $mode init] } {
        set at91sam4l_pending_halt 1;
    }

    # slow the adapter down, as post-reset will be RCLOCAL
    global _SLOWSPEED
    adapter_khz $_SLOWSPEED
}

# SAM4L SMAP will hold the CPU in reset if TCK is low when nRESET
# deasserts (see datasheet 42023E-SAM-07/2013 sec 8.11.3).
#
# We need to configure whether we want to run or halt out of reset,
# then instruct the SMAP to let us out of reset
proc at91sam4l_reset_deassert_post {} {
    global at91sam4l_pending_halt

    # Register addresses/masks we need
    set ADDR_DCB_DHCSR	0xE000EDF0
    set BIT_DHCSR_DEBUGKEY [expr 0xA05F << 16]
    set BIT_DHCSR_DEBUGEN [expr 1 << 0]
    set ADDR_DCB_DEMCR 0xE000EDFC
    set BIT_DEMCR_VC_CORERESET [expr 1 << 0]
    set ADDR_SMAP_SCR 0x400A3008
    set BIT_HCR [expr 1 << 1]

    poll on
    sleep 20

    if { $at91sam4l_pending_halt } {
        # Set reset vector catch so we halt when reset releases
        mww $ADDR_DCB_DEMCR [expr [ mrw $ADDR_DCB_DEMCR ] | $BIT_DEMCR_VC_CORERESET ]
        mww $ADDR_DCB_DHCSR [expr $BIT_DHCSR_DEBUGEN | $BIT_DHCSR_DEBUGKEY ]
    }

    # SCR.HCR, release reset
    mww $ADDR_SMAP_SCR $BIT_HCR
}

# Reset comes up at 115kHz RCLOCAL, so switch to RC80M during init
proc at91sam4l_reset_init {} {
    echo "ATSAM4L: Switching to RC80M for 40MHz cpu/peripheral clock"

    # Registers we need
    set ADDR_SCIF_BASE 0x400E0800
    set OFFS_SCIF_UNLOCK 0x0018
    set OFFS_RC80MCR 0x50
    set BIT_RC80MCR_EN [expr 1 << 0]

    set ADDR_PM_BASE 0x400E0000
    set OFFS_MCCTRL 0x00
    set MASK_MCCTRL_RC80M 0x04
    set OFFS_SR     0xD4
    set BIT_CKRDY  [expr 1 << 5]
    set OFFS_PM_UNLOCK 0x0058
    set OFFS_CPUSEL 0x04
    set OFFS_PBASEL 0x0C
    set OFFS_PBBSEL 0x10
    set OFFS_PBCSEL 0x14
    set OFFS_PBDSEL 0x18
    set BIT_SEL_DIV [expr 1 << 7]
    set UNLOCK_KEY [expr 0xAA << 8]

    # enable RC80M clock
    mww [expr $ADDR_SCIF_BASE + $OFFS_SCIF_UNLOCK] [expr $UNLOCK_KEY + $OFFS_RC80MCR]
    mww [expr $ADDR_SCIF_BASE + $OFFS_RC80MCR] $BIT_RC80MCR_EN
    while {[expr [mrw [expr $ADDR_SCIF_BASE + $OFFS_RC80MCR]] & $BIT_RC80MCR_EN] == 0} { sleep 1 }

    # as soon as we set CPUSEL to /2 we'll need a matching
    # a 2x slower JTAG speed
    global _SLOWSPEED
    adapter_khz [expr $_SLOWSPEED / 2]

    # set all main clock dividers to /2
    foreach offs { $OFFS_CPUSEL $OFFS_PBASEL $OFFS_PBBSEL $OFFS_PBCSEL $OFFS_PBDSEL } {
        mww [expr $ADDR_PM_BASE + $OFFS_PM_UNLOCK] [expr $UNLOCK_KEY + $offs]
        mww [expr $ADDR_PM_BASE + $offs] [expr $BIT_SEL_DIV ]
        while {[expr [mrw [expr $ADDR_PM_BASE + $OFFS_SR]] & $BIT_CKRDY] == 0} { sleep 1 }
    }

    # switch main clock source to RC80M
    mww [expr $ADDR_PM_BASE + $OFFS_PM_UNLOCK] [expr $UNLOCK_KEY + $OFFS_MCCTRL]
    mww [expr $ADDR_PM_BASE + $OFFS_MCCTRL] $MASK_MCCTRL_RC80M

    global _MAXSPEED
    adapter_khz $_MAXSPEED
}

# Without SRST (wired to N_RESET) SAM4L won't reset cleanly
reset_config srst_only

# SAM4L starts from POR with SYSCLK set to 115kHz RCLOCAL, needs slow JTAG
adapter_khz $_SLOWSPEED
