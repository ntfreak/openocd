tcl_port 6666
telnet_port 4444
gdb_port 3333


global _CHIPNAME
global _ENDIAN
global _IRLEN
global _IRCAP
global _IRMASK
global _CPU_TAPID
global _NCPUS
global _SMP

if { [info exists INTERFACE] } {
	source [find $INTERFACE]
} else {
	source [find interface/bejtag.cfg]
}

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME armv8cpu
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
 # this defaults to a bigendian
	set _ENDIAN little
}

if { [info exists IRLEN] } {
   set _IRLEN $IRLEN
} else {
   set _IRLEN 4
}

if { [info exists IRCAP] } {
   set _IRCAP $IRCAP
} else {
   set _IRCAP 0x1
}

if { [info exists IRMASK] } {
   set _IRMASK $IRMASK
} else {
   set _IRMASK 0xf
}

# default working area is 16384
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

if { [info exists NCPUS] } {
   set _NCPUS $NCPUS
} else {
   set SMP 1
   set _SMP 1
   set _NCPUS 2
}

if {![info exists SMP]} {
	set _SMP 1
} else {
	set _SMP $SMP
}

for { set i 0 } { $i < [expr {$_NCPUS} ] } { incr i } {
	set _TARGETNAME$i $_CHIPNAME.cpu$i
	global _TARGETNAME$i
}

#
# A57/A53 DAP
#
if { [info exists CPU_TAPID] } {
	set _CPU_TAPID $CPU_TAPID
} else {
	set _CPU_TAPID 0x5BA00477
}

# jtag newtap $_CHIPNAME tap -irlen $_IRLEN -expected-id $_CPU_TAPID
jtag newtap cortex-m3 dap -irlen 4 -expected-id 0x5BA00477
jtag newtap armv8     dap -irlen 4 -expected-id 0x5BA00477


# DBGBASE
#						CORE		CTI			PMU			ETM
#   Cortex-A57 Core 0  0x82010000	0x82020000	0x82030000	0x82040000
#   Cortex-A57 Core 1  0x82110000	0x82120000	0x82130000	0x82140000
#	TFunnel            0x820C0000
#   Cortex-A53 Core 0  0x83010000	0x83020000	0x83030000	0x83040000
#   Cortex-A53 Core 1  0x83110000	0x83120000	0x83130000	0x83140000
#   Cortex-A53 Core 2  0x83210000	0x83220000	0x83230000	0x83240000
#   Cortex-A53 Core 3  0x83310000	0x83320000	0x83330000	0x83340000
#	TFunnel            0x830C0000

target create a57.cpu0 aarch64 -endian little -chain-position armv8.dap -coreid 0 -dbgbase 0x82010000
target create a57.cpu1 aarch64 -endian little -chain-position armv8.dap -coreid 1 -dbgbase 0x82110000
#target create a53.cpu0 aarch64 -endian little -chain-position armv8.dap -coreid 0
#target create a53.cpu1 aarch64 -endian little -chain-position armv8.dap -coreid 1
#target create a53.cpu2 aarch64 -endian little -chain-position armv8.dap -coreid 2
#target create a53.cpu3 aarch64 -endian little -chain-position armv8.dap -coreid 3 -dbgbase 0x83310000

#a57.cpu0 configure -work-area-virt 0x00000000 -work-area-size 0x4000 -work-area-backup 1
#a57.cpu1 configure -work-area-virt 0x00000000 -work-area-size 0x4000 -work-area-backup 1


set _SMP_TARGETS "target smp "
global _SMP_TARGTES

# target smp a57.cpu0 a57.cpu1 ...
append _SMP_TARGETS a57.cpu0 " "
append _SMP_TARGETS a57.cpu1 " "

if {$_SMP == 1} {
	eval $_SMP_TARGETS
}


#adapter_khz 555
#init

set _NCPUS 2
#
# configure polling on/off based on events from gdb and jtag probe
#
for { set i 0 } { $i < $_NCPUS } { incr i }  {
#	set cpu [ format "$_CHIPNAME.cpu%d" $i ]
	set cpu [ format "a57.cpu%d" $i ]

#	$cpu configure -event examine-start {	# Alamy: This cause problem
#		dap apsel 1			# arm_adi_v5.h(435): dap_queue_ap_read: Assertion
#	}					# `dap->ops != ((void *)0)` failed.

	# Poll is default ON, stop it
	$cpu configure -event examine-end {
		dap apsel 1
		poll off
	}

#	$cpu configure -event gdb-attach {
#		aarch64 dbginit
# Hacking, know which CPU initiate dbginit
#		aarch64 dbginit $cpu
#		halt
# No poll is good for UEFI
#		poll
#	}

#	$cpu configure -event gdb-detach {
#		resume
#		poll off
#		shutdown
#	}

	$cpu configure -event gdb-halt {
#		aarch64 dbginit
		poll off
	}

#    $cpu configure -event gdb-start {
#	  	poll on
#	}

	$cpu configure -event gdb-end {
		poll off
	}

	$cpu configure -event resume-end {
		poll on
	}

}

#a57.cpu0 configure -work-area-virt 0x00000000 -work-area-size 0x4000 -work-area-backup 1
#a57.cpu1 configure -work-area-virt 0x00000000 -work-area-size 0x4000 -work-area-backup 1

# Hacking, we need $cpu being passed to 'dbginit' command
# No poll is good for UEFI
a57.cpu0 configure -event gdb-attach {
		aarch64 dbginit
		halt
}
a57.cpu1 configure -event gdb-attach {
		aarch64 dbginit
		halt
}


# initialize only board specifics - reset, clock, adapter frequency
proc init_board {} {
	adapter_nsrst_delay 500
	jtag_ntrst_delay 500
#	jtag_rclk 27000
	jtag_rclk 10000
#	adapter_khz 10

	#reset configuration (srst_only, trst_only, trst_and_srst)
	reset_config srst_only
}

#proc init_reset {mode} {
#	jtag_rclk 444
#}

proc smp_reg {} {
	global _CHIPNAME
	global _NCPUS

	set _current_target [target current]

	for { set i 0 } { $i < $_NCPUS } { incr i } {
#		set t [ format "$_CHIPNAME.cpu%d" $i ]
		set t [ format "a57.cpu%d" $i ]

		targets $t
		echo "$t"
		set x0 [reg x0]
		set x1 [reg x1]
		set x2 [reg x2]
		set x3 [reg x3]
		set x4 [reg x4]
		set x5 [reg x5]
		set x6 [reg x6]
		set x7 [reg x7]
		set x8 [reg x8]
		set x9 [reg x9]
		set x10 [reg x10]
		set x11 [reg x11]
		set x12 [reg x12]
		set x13 [reg x13]
		set x14 [reg x14]
		set x15 [reg x15]
		set x16 [reg x16]
		set x17 [reg x17]
		set x18 [reg x18]
		set x19 [reg x19]
		set x20 [reg x20]
		set x21 [reg x21]
		set x22 [reg x22]
		set x23 [reg x23]
		set x24 [reg x24]
		set x25 [reg x25]
		set x26 [reg x26]
		set x27 [reg x27]
		set x28 [reg x28]
		set x29 [reg x29]
		set x30 [reg x29]
		set pc [reg pc]
		set sp [reg sp]
	}

	targets $_current_target
}

proc rst_run { } {
	global _CHIPNAME
	global _NCPUS
	set _curtarget [target current]
	for { set i 0 } { $i < $_NCPUS } { incr i } {
		set t [ format "$_CHIPNAME.cpu%d" $i ]

		set status [$t curstate]
		if {[string equal "halted" $status]} {
			resume
			targets $t
		}
	}
	poll off
	jtag arp_init
	reset
	sleep 20
	poll on
	targets $_curtarget

	dap apsel 1
}

proc ocd_gdb_restart {target_id} {
	global _TARGETNAME_1
	global _SMP
	targets $_TARGETNAME_1
	if { [expr ($_SMP == 1)] } {
		cortex_a smp_off
	}
	rst_run
	halt
	if { [expr ($_SMP == 1)]} {
	cortex_a smp_on
	}
}

# ARM Core specific hacks
#etm config a57.cpu0 16 normal full etb
#etb config a57.cpu0 a57.etb


gdb_breakpoint_override hard
# set mem inaccessible-by-default-off
