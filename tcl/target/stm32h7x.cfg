# script for stm32h7x family

#
# stm32h7 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stm32h7x
}

if { [info exists DUAL_BANK] } {
	set $_CHIPNAME.DUAL_BANK $DUAL_BANK
	unset DUAL_BANK
} else {
	set $_CHIPNAME.DUAL_BANK 0
}

if { [info exists DUAL_CORE] } {
	set $_CHIPNAME.DUAL_CORE $DUAL_CORE
	unset DUAL_CORE
} else {
	set $_CHIPNAME.DUAL_CORE 0
}

# Issue a warning when hla is used, and fallback to single core configuration
if { [set $_CHIPNAME.DUAL_CORE] && [using_hla] } {
	echo "Warning : hla does not support multicore debugging"
	set $_CHIPNAME.DUAL_CORE 0
}

if { [info exists USE_CTI] } {
	set $_CHIPNAME.USE_CTI $USE_CTI
	unset USE_CTI
} else {
	set $_CHIPNAME.USE_CTI 0
}

# Issue a warning when DUAL_CORE=0 and USE_CTI=1, and fallback to USE_CTI=0
if { ![set $_CHIPNAME.DUAL_CORE] && [set $_CHIPNAME.USE_CTI] } {
	echo "Warning : could not use CTI with a single core device, CTI is disabled"
	set $_CHIPNAME.USE_CTI 0
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x10000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	if { [using_jtag] } {
		set _CPUTAPID 0x6ba00477
	} {
		set _CPUTAPID 0x6ba02477
	}
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
	swj_newdap $_CHIPNAME bs -irlen 5
}

target create $_CHIPNAME.cpu0 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_CHIPNAME.cpu0 configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

flash bank $_CHIPNAME.bank1.cpu0 stm32h7x 0x08000000 0 0 0 $_CHIPNAME.cpu0

if {[set $_CHIPNAME.DUAL_BANK]} {
	flash bank $_CHIPNAME.bank2.cpu0 stm32h7x 0x08100000 0 0 0 $_CHIPNAME.cpu0
}

if {![using_hla]} {
	# STM32H7 provides an APB-AP at access port 2, which allows the access to
	# the debug and trace features on the system APB System Debug Bus (APB-D).
	target create $_CHIPNAME.ap2 mem_ap -dap $_CHIPNAME.dap -ap-num 2
}

if {[set $_CHIPNAME.DUAL_CORE]} {
	target create $_CHIPNAME.cpu1 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num 3 -defer-examine

	$_CHIPNAME.cpu1 configure -work-area-phys 0x38000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

	flash bank $_CHIPNAME.bank1.cpu1 stm32h7x 0x08000000 0 0 0 $_CHIPNAME.cpu1

	if {[set $_CHIPNAME.DUAL_BANK]} {
		flash bank $_CHIPNAME.bank2.cpu1 stm32h7x 0x08100000 0 0 0 $_CHIPNAME.cpu1
	}
}

# Make sure that cpu0 is selected
targets $_CHIPNAME.cpu0

# Clock after reset is HSI at 64 MHz, no need of PLL
adapter_khz 1800

adapter_nsrst_delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

# use hardware reset
#
# The STM32H7 does not support connect_assert_srst mode because the AXI is
# unavailable while SRST is asserted, and that is used to access the DBGMCU
# component at 0x5C001000 in the examine-end event handler.
#
# It is possible to access the DBGMCU component at 0xE00E1000 via AP2 instead
# of the default AP0, and that works with SRST asserted; however, nonzero AP
# usage does not work with HLA, so is not done by default. That change could be
# made in a local configuration file if connect_assert_srst mode is needed for
# a specific application and a non-HLA adapter is in use.
reset_config srst_only srst_nogate

if {![using_hla]} {
	# if srst is not fitted use SYSRESETREQ to
	# perform a soft reset
	$_CHIPNAME.cpu0 cortex_m reset_config sysresetreq

	if {[set $_CHIPNAME.DUAL_CORE]} {
		$_CHIPNAME.cpu1 cortex_m reset_config sysresetreq
	}

	# Set CSW[27], which according to ARM ADI v5 appendix E1.4 maps to AHB signal
	# HPROT[3], which according to AMBA AHB/ASB/APB specification chapter 3.7.3
	# makes the data access cacheable. This allows reading and writing data in the
	# CPU cache from the debugger, which is far more useful than going straight to
	# RAM when operating on typical variables, and is generally no worse when
	# operating on special memory locations.
	$_CHIPNAME.dap apcsw 0x08000000 0x08000000
}

$_CHIPNAME.cpu0 configure -event examine-end {
	# get _CHIPNAME from the current target
	set _CHIPNAME [regsub ".cpu\\d$" [target current] ""]

	# Enable D3 and D1 DBG clocks
	# DBGMCU_CR |= D3DBGCKEN | D1DBGCKEN
	mmw 0x5C001004 0x00600000 0

	# Enable debug during low power modes (uses more power)
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP in D3, D2 & D1 Domains
	mmw 0x5C001004 0x000001BF 0

	# Stop watchdog counters during halt
	# DBGMCU_APB3FZ1 |= WWDG1
	mmw 0x5C001034 0x00000040 0
	# DBGMCU_APB1LFZ1 |= WWDG2
	mmw 0x5C00103C 0x00000800 0
	# DBGMCU_APB4FZ1 |= WDGLSD1 | WDGLSD2
	mmw 0x5C001054 0x000C0000 0

	if {[set $_CHIPNAME.DUAL_CORE] && [stm32h7x_is_cpu1_alive]} {
		$_CHIPNAME.cpu1 arp_examine

		if {[set $_CHIPNAME.USE_CTI]} {
			stm32h7x_cti_start
		}
	}
}

$_CHIPNAME.cpu0 configure -event trace-config {
	# Set TRACECLKEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0x5C001004 0x00100000 0
}

$_CHIPNAME.cpu0 configure -event reset-init {
	# Clock after reset is HSI at 64 MHz, no need of PLL
	adapter_khz 4000
}

proc stm32h7x_is_cpu1_alive {} {
	# get _CHIPNAME from the current target
	set _CHIPNAME [regsub ".cpu\\d$" [target current] ""]

	# Check that Cortex-M4 is present (bit 16 of chip options register from SYSCFG)
	# RCC_APB4ENR |= SYSCFGEN
	mmw 0x580244F4 0x00000002 0
	$_CHIPNAME.cpu0 mem2array chip_options 32 0x58000500 1
	if { ![expr {$chip_options(0) & 0x10000}] } {
		echo "Error : This chip does not contain a second core"
		return false
	}

	# Check that Cortex-M4 is allowed to boot (check FLASH_OPTSR.BCM4 and RCC_CGR.BOOT_C2 bits)
	# BCM4 = FLASH_OPTSR_CUR[22]
	# BOOT_C2 = RCC_CGR[3]
	# If BOOT_C2 is set, the CM4 will boot independently of BCM4
	# IF BOOT_C2 is 0, the CM4 will boot only if BCM4 is set
	# => the CM4 will not boot only if both of BOOT_C2 and BCM4 are 0

	$_CHIPNAME.cpu0 mem2array FLASH_OPTSR 32 0x5200201C 1
	$_CHIPNAME.cpu0 mem2array RCC_CGR 32 0x580244A0 1

	if { ![expr {$FLASH_OPTSR(0) & 0x400000}] && ![expr {$RCC_CGR(0) & 0x8}] } {
		echo "Warning : The Cortex-M4 is not allowed to boot"
		return false
	}

	# Check that Cortex-M4 is clocked (check SYSCFG_UR1.BCM4)
	# BCM4 = SYSCFG_UR1[0]
	# Cortex-M4 core is clock gated if BCM4 is 0

	$_CHIPNAME.cpu0 mem2array SYSCFG_UR1 32 0x58000704 1

	if { ![expr {$SYSCFG_UR1(0) & 0x1}] } {
		echo "Warning : The Cortex-M4 is clock gated"
		return false
	}

	return true
}

if {[set $_CHIPNAME.DUAL_CORE]} {
	$_CHIPNAME.cpu1 configure -event examine-end {
		# Stop watchdog counters during halt
		# DBGMCU_APB3FZ2 |= WWDG1
		mmw 0x5C001038 0x00000040 0
		# DBGMCU_APB1LFZ2 |= WWDG2
		mmw 0x5C001040 0x00000800 0
		# DBGMCU_APB4FZ2 |= WDGLSD1 | WDGLSD2
		mmw 0x5C001058 0x000C0000 0
	}
}

if {[set $_CHIPNAME.USE_CTI]} {

	# create CTI instances for both cores
	cti create $_CHIPNAME.cti0 -dap $_CHIPNAME.dap -ap-num 0 -ctibase 0xE0043000
	cti create $_CHIPNAME.cti1 -dap $_CHIPNAME.dap -ap-num 3 -ctibase 0xE0043000

	$_CHIPNAME.cpu0 configure -event halted { stm32h7x_cti_prepare_restart_all }
	$_CHIPNAME.cpu1 configure -event halted { stm32h7x_cti_prepare_restart_all }

	proc stm32h7x_cti_start {} {
		# get _CHIPNAME from the current target
		set _CHIPNAME [regsub ".cpu\\d$" [target current] ""]

		# Configure Cores' CTIs to halt each other
		# TRIGIN0 (DBGTRIGGER) and TRIGOUT0 (EDBGRQ) at CTM_CHANNEL_0
		$_CHIPNAME.cti0 write INEN0 0x1
		$_CHIPNAME.cti0 write OUTEN0 0x1
		$_CHIPNAME.cti1 write INEN0 0x1
		$_CHIPNAME.cti1 write OUTEN0 0x1

		# enable CTIs
		$_CHIPNAME.cti0 enable on
		$_CHIPNAME.cti1 enable on
	}

	proc stm32h7x_cti_stop {} {
		# get _CHIPNAME from the current target
		set _CHIPNAME [regsub ".cpu\\d$" [target current] ""]

		$_CHIPNAME.cti0 enable off
		$_CHIPNAME.cti1 enable off
	}

	proc stm32h7x_cti_prepare_restart_all {} {
		stm32h7x_cti_prepare_restart cti0
		stm32h7x_cti_prepare_restart cti1
	}

	proc stm32h7x_cti_prepare_restart {cti} {
		# get _CHIPNAME from the current target
		set _CHIPNAME [regsub ".cpu\\d$" [target current] ""]

		# Acknowlodge EDBGRQ at TRIGOUT0
		$_CHIPNAME.$cti write INACK 0x01
		$_CHIPNAME.$cti write INACK 0x00
	}
}
