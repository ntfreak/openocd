# script for stm32h7x family

#
# stm32h7 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME stm32h7x
}

if { [info exists DUAL_CORE] } {
   set _DUAL_CORE $DUAL_CORE
} else {
   set _DUAL_CORE 0
}

# Issue a warning when hla is used, and fallback to single core configuration
if { $_DUAL_CORE && [using_hla] } {
  echo "Warning : hla does not support multicore debugging"
  set _DUAL_CORE 0
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x10000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
	  set _CPUTAPID 0x6ba00477
   } {
      set _CPUTAPID 0x6ba02477
   }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
 swj_newdap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu0

target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap


if {![using_hla]} {
	# STM32H7 provides an APB-AP at access port 2, which allows the access to
	# the debug and trace features on the system APB System Debug Bus (APB-D).
	target create $_CHIPNAME.ap2 mem_ap -dap $_CHIPNAME.dap -ap-num 2

	if {$_DUAL_CORE} {
		target create $_CHIPNAME.cpu1 cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num 3 -defer-examine
	}
}

# Make sure that cpu0 is selected
targets $_TARGETNAME

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32h7x 0x08000000 0 0 0 $_TARGETNAME

# Clock after reset is HSI at 64 MHz, no need of PLL
adapter_khz 1800

adapter_nsrst_delay 100
if {[using_jtag]} {
 jtag_ntrst_delay 100
}

# use hardware reset
#
# The STM32H7 does not support connect_assert_srst mode because the AXI is
# unavailable while SRST is asserted, and that is used to access the DBGMCU
# component at 0x5C001000 in the examine-end event handler.
#
# It is possible to access the DBGMCU component at 0xE00E1000 via AP2 instead
# of the default AP0, and that works with SRST asserted; however, nonzero AP
# usage does not work with HLA, so is not done by default. That change could be
# made in a local configuration file if connect_assert_srst mode is needed for
# a specific application and a non-HLA adapter is in use.
reset_config srst_only srst_nogate

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq

   # Set CSW[27], which according to ARM ADI v5 appendix E1.4 maps to AHB signal
   # HPROT[3], which according to AMBA AHB/ASB/APB specification chapter 3.7.3
   # makes the data access cacheable. This allows reading and writing data in the
   # CPU cache from the debugger, which is far more useful than going straight to
   # RAM when operating on typical variables, and is generally no worse when
   # operating on special memory locations.
   $_CHIPNAME.dap apcsw 0x08000000 0x08000000
}

$_TARGETNAME configure -event examine-end {
	# Enable D3 and D1 DBG clocks
	# DBGMCU_CR |= D3DBGCKEN | D1DBGCKEN
	mmw 0x5C001004 0x00600000 0

	# Enable debug during low power modes (uses more power)
	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP in D3 & D1 Domains
	mmw 0x5C001004 0x00000187 0

	# Stop watchdog counters during halt
	# DBGMCU_APB3FZ1 |= WWDG1
	mmw 0x5C001034 0x00000040 0
	# DBGMCU_APB4FZ1 |= WDGLSD1
	mmw 0x5C001054 0x00040000 0

	if {$_DUAL_CORE} {
		cortex_m4_init
	}
}

proc cortex_m4_init {} {
	global _TARGETNAME
	global _CHIPNAME

	# Check that Cortex-M4 is present (bit 16 of chip options register from SYSCFG)
	# RCC_APB4ENR |= SYSCFGEN
	mmw 0x580244F4 0x00000002 0
	$_TARGETNAME mem2array chip_options 32 0x58000500 1
	if { ![expr {$chip_options(0) & 0x10000}] } {
		echo "Error : This chip does not contain a second core"
		return
	}

	# Check that Cortex-M4 is allowed to boot (check FLASH_OPTSR.BCM4 and RCC_CGR.BOOT_C2 bits)
	# BCM4 = FLASH_OPTSR_CUR[22]
	# BOOT_C2 = RCC_CGR[3]
	# If BOOT_C2 is set, the CM4 will boot independently of BCM4
	# IF BOOT_C2 is 0, the CM4 will boot only if BCM4 is set
	# => the CM4 will not boot only if both of BOOT_C2 and BCM4 are 0

	$_TARGETNAME mem2array flash_optsr 32 0x5200201C 1
	$_TARGETNAME mem2array rcc_cgr 32 0x580244A0 1

	if { ![expr {$flash_optsr(0) & 0x400000}] && ![expr {$rcc_cgr(0) & 0x8}] } {
		echo "Warning : The Cortex-M4 is not allowed to boot"
		return
	}

	# Check that Cortex-M4 is clocked (check SYSCFG_UR1.BCM4)
	# BCM4 = SYSCFG_UR1[0]
	# Cortex-M4 core is clock gated if BCM4 is 0

	$_TARGETNAME mem2array syscfg_ur1 32 0x58000704 1

	if { ![expr {$syscfg_ur1(0) & 0x1}] } {
		echo "Warning : The Cortex-M4 is clock gated"
		return
	}

	# Examine the CM4
	$_CHIPNAME.cpu1 arp_examine
}

$_TARGETNAME configure -event trace-config {
	# Set TRACECLKEN; TRACE_MODE is set to async; when using sync
	# change this value accordingly to configure trace pins
	# assignment
	mmw 0x5C001004 0x00100000 0
}

$_TARGETNAME configure -event reset-init {
	# Clock after reset is HSI at 64 MHz, no need of PLL
	adapter_khz 4000
}

