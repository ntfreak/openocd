# script for Cypress PSoC 41xx/42xx family

#
# PSoC 4 devices support SWD transports only.
#
source [find target/swj-dp.tcl]

if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME psoc4
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 4kB
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x1000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0x0bb11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME psoc4 0 0 0 0 $_TARGETNAME

adapter_khz 1500

# Reset, bloody PSoC 4 reset
#
# 1) XRES (nSRST) resets also SWD DP so SWD line reset and DP reinit is needed
# Workaround for low level adapters can be enabled in cortex_m target driver:
#   cortex_m psoc4_reset_quirk 1
# High level adapter stops working after SRST and needs OpenOCD restart.
# If your hw does not use SRST for other circuits, use sysresetreq instead
#
# 2) PSoC 4 executes initialization code from system ROM after reset.
# This code subsequently jumps to user flash reset vector address.
# Unfortunately the system ROM code is protected from reading and debugging.
# Protection breaks vector catch VC_CORERESET used for "reset halt" by cortex_m.
# Cypress uses TEST_MODE flag to loop CPU in system ROM before executing code
# from user flash. Programming specifications states that TEST_MODE flag must be
# set in time frame 400 usec delayed about 1 msec from reset.
# If you have low level adapter fast enough use adapter_khz at least 1500
# and set
#   cortex_m psoc4_reset_quirk 3
#
# For high level adapter and slower low level adapters TEST_MODE flag is set
# before reset. It worked for tested chips despite it is not guaranteed
# by specification.
# If applicable, both methods are used simultaneously. No harm if TEST_MODE flag
# is set twice.
#
# 3) SWD cannot be connected during system initialization after reset.
# I have not encountered this problem on an old ftdi FT2232C adapter.
# If you have a faster low level adapter you may need to set delay:
#   cortex_m psoc4_reset_delay 100

if {![using_hla]} {
   # if srst is not fitted use SYSRESETREQ to
   # perform a soft reset
   cortex_m reset_config sysresetreq
   cortex_m psoc4_reset_quirk 3
}

proc ocd_process_reset_inner { MODE } {
	if { 0 != [string compare psoc4.cpu [target names]] } {
		return -code error "PSoC 4 reset can handle only one psoc4.cpu target";
	}
	set t psoc4.cpu

	# If this target must be halted...
	set halt -1
	if { 0 == [string compare $MODE halt] } {
		set halt 1
	}
	if { 0 == [string compare $MODE init] } {
		set halt 1;
	}
	if { 0 == [string compare $MODE run ] } {
		set halt 0;
	}
	if { $halt < 0 } {
		return -code error "Invalid mode: $MODE, must be one of: halt, init, or run";
	}

	if {[using_hla]} {
		# do not use halt on high level adapter
		set halt_fixed 0
	} else {
		# cortex_m has support for PSoC 4 test mode
		set halt_fixed $halt
	}

	#$t invoke-event reset-start
	$t invoke-event reset-assert-pre

	set TEST_MODE 0x40030014
	if { $halt == 1 } {
		mww $TEST_MODE 0x80000000
	} else {
		mww $TEST_MODE 0
	}

	$t arp_reset assert $halt_fixed
	$t invoke-event reset-assert-post
	$t invoke-event reset-deassert-pre
	if {![using_hla]} {	# workaround ST-Link v2 fails and forcing reconnect
		$t arp_reset deassert $halt_fixed
	}
	$t invoke-event reset-deassert-post

	# Pass 1 - Now wait for any halt (requested as part of reset
	# assert/deassert) to happen.  Ideally it takes effect without
	# first executing any instructions.
	if { $halt } {
		# Now PSoC CPU should loop in system rom
		$t arp_waitstate running 200
		$t arp_halt

		# Catch, but ignore any errors.
		catch { $t arp_waitstate halted 1000 }

		# Did we succeed?
		set s [$t curstate]

		if { 0 != [string compare $s "halted" ] } {
			return -code error [format "TARGET: %s - Not halted" $t]
		}

		# Set registers to reset vector values
		mem2array value 32 0 2
		reg pc [expr $value(1) & 0xfffffffe ]
		reg msp $value(0)

		mww $TEST_MODE 0
	}

	#Pass 2 - if needed "init"
	if { 0 == [string compare init $MODE] } {
		set err [catch "$t arp_waitstate halted 5000"]

		# Did it halt?
		if { $err == 0 } {
			$t invoke-event reset-init
		}
	}

	$t invoke-event reset-end
}
