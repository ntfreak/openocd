tcl_port 6666
telnet_port 4444
gdb_port 3333

if { [info exists INTERFACE] } {
	source [find $INTERFACE]
} else {
	source [find interface/bejtag.cfg]
}

if { [info exists CHIPNAME] } {
global _CHIPNAME
    set _CHIPNAME $CHIPNAME
} else {
global _CHIPNAME
	set _CHIPNAME armv8cpu
}

if { [info exists ENDIAN] } {
	set _ENDIAN $ENDIAN
} else {
 # this defaults to a bigendian
	set _ENDIAN little
}

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME armv8cpu
}


if { [info exists IRLEN] } {
   set _IRLEN $IRLEN
} else {
   set _IRLEN 4
}

if { [info exists IRCAP] } {
   set _IRCAP $IRCAP
} else {
   set _IRCAP 0x1
}

if { [info exists IRCAP] } {
   set _IRCAP $IRCAP
} else {
   set _IRCAP 0x1
}

if { [info exists IRMASK] } {
   set _IRMASK $IRMASK
} else {
   set _IRMASK 0xf
}

# default working area is 16384
if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

if { [info exists NCPUS] } {
   set _NCPUS $NCPUS
} else {
   global _SMP
   set SMP 1
   set _SMP 1
   set _NCPUS 2
}

if {![info exists SMP]} {
	global _SMP
	set _SMP 1
} else {
	global _SMP
	set _SMP $SMP
}

for { set i 0 } { $i < [expr {$_NCPUS} ] } { incr i } {
	set _TARGETNAME$i $_CHIPNAME.cpu$i
	global _TARGETNAME$i
}

global _IRCAP
global _IRMASK
global _IRLEN
global _CPUTAPID
global _NCPU

#
# A57/A53 DAP
#
if { [info exists CPU_TAPID] } {
	set _CPU_TAPID $CPU_TAPID
} else {
	set _CPU_TAPID 0x5BA00477
}

# jtag newtap $_CHIPNAME tap -irlen $_IRLEN -expected-id $_CPU_TAPID
jtag newtap cortex-m3 dap -irlen 4 -expected-id 0x5BA00477
jtag newtap armv8     dap -irlen 4 -expected-id 0x5BA00477


# DBGBASE
#						CORE		CTI			PMU			ETM
#   Cortex-A57 Core 0  0x82010000	0x82020000	0x82030000	0x82040000
#   Cortex-A57 Core 1  0x82110000	0x82120000	0x82130000	0x82140000
#	TFunnel            0x820C0000
#   Cortex-A53 Core 0  0x83010000	0x83020000	0x83030000	0x83040000
#   Cortex-A53 Core 1  0x83110000	0x83120000	0x83130000	0x83140000
#   Cortex-A53 Core 2  0x83210000	0x83220000	0x83230000	0x83240000
#   Cortex-A53 Core 3  0x83310000	0x83320000	0x83330000	0x83340000
#	TFunnel            0x830C0000

set _SMP_TARGETS "target smp "
global _SMP_TARGTES

target create a57.cpu0 aarch64 -endian little -chain-position armv8.dap -coreid 0 -dbgbase 0x82010000
#target create a57.cpu1 aarch64 -endian little -chain-position armv8.dap -coreid 1 -dbgbase 0x82110000
#target create a53.cpu0 aarch64 -endian little -chain-position armv8.dap -coreid 0
#target create a53.cpu1 aarch64 -endian little -chain-position armv8.dap -coreid 1
#target create a53.cpu2 aarch64 -endian little -chain-position armv8.dap -coreid 2
#target create a53.cpu3 aarch64 -endian little -chain-position armv8.dap -coreid 3 -dbgbase 0x83310000



#adapter_khz 555
#init

set _NCPUS 1
#
# configure polling on/off based on events from gdb and jtag probe
#
for { set i 0 } { $i < $_NCPUS } { incr i }  {
#	set cpu [ format "$_CHIPNAME.cpu%d" $i ]
	set cpu [ format "a57.cpu%d" $i ]

#	$cpu configure -event examine-start {	# Alamy: This cause problem
#		dap apsel 1			# arm_adi_v5.h(435): dap_queue_ap_read: Assertion
#	}					# `dap->ops != ((void *)0)` failed.

	$cpu configure -event examine-end {
		dap apsel 1
		poll off
	}

	$cpu configure -event gdb-attach {
		aarch64 dbginit
		halt
#		poll on
	}



	$cpu configure -event gdb-halt {
#		aarch64 dbginit
		poll off
	}

	$cpu configure -event resume-end {
		poll on
	}

}

# initialize only board specifics - reset, clock, adapter frequency
proc init_board {} {
	adapter_nsrst_delay 500
	jtag_ntrst_delay 500
#	jtag_rclk 27000
	jtag_rclk 10000
#	adapter_khz 10

	#reset configuration (srst_only, trst_only, trst_and_srst)
	reset_config srst_only
}

#proc init_reset {mode} {
#	jtag_rclk 444
#}

gdb_breakpoint_override hard

