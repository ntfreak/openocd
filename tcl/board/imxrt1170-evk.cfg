source [find interface/cmsis-dap.cfg]
transport select swd

source [find target/imxrt1170_cm7.cfg]

proc semc_wait_ipcmddone {} {
    mem2array reg 32 0x400d403c 1
    while { [expr $reg(0) & 0x3 ] == 0 } {
        mem2array reg 32 0x400d403c 1
        sleep 10
    }
    # clear IPCMDERR and IPCMDDONE bits
    mww 0x400d403c 0x00000003
}

proc setup_vec {} {
    mww 0x2001ff04 0x00207e11
    # Vector table offset register out of reset
    mww 0x400e404c 0x004003fe
}

proc clear_pending_irq {} {
    # Disable all IRQ: ICERn
    # NVIC Base (0xE000E100) + 0x080
    mww  0xe000e180 0xffffffff 8

    # Clear pending IRQ: ICPRn */
    # NVIC Base (0xE000E100) + 0x180
    mww  0xe000e280 0xffffffff 8

    echo "Info : clear_pending_irq"
}

# Setup the "Smart External Memory Controller"
# Clock source to use SYS_PLL2_PFD2 divided by 3 -> 176Mhz
proc semc_clk_root_setup {} {
    set SYS_PLL2_PFD2   6
    set SEMC_CLOCK_DIV  3
    set LPCG33          33

    # semc_clk_root has CLOCK_ROOT4 as control register, pg1364
    root_clock_mux [CLOCK_ROOT 4] $SYS_PLL2_PFD2
    root_clock_div [CLOCK_ROOT 4] $SEMC_CLOCK_DIV

    # LPCG33 is gate-controlling CLOCK_ROOT4, pg1382
    clock_gate_enable $LPCG33
    echo "Info : semc_clk_root_setup."
}
proc semc_iomuxc_mux {} {
    # GPIO_EMC_B1_00 -> SEMC_DATA00
    iomuxc_set_reg 0x010 0x00
    # GPIO_EMC_B1_01 -> SEMC_DATA01
    iomuxc_set_reg 0x014 0x00
    iomuxc_set_reg 0x018 0x00
    iomuxc_set_reg 0x01C 0x00
    iomuxc_set_reg 0x020 0x00
    iomuxc_set_reg 0x024 0x00
    iomuxc_set_reg 0x028 0x00
    iomuxc_set_reg 0x02C 0x00
    iomuxc_set_reg 0x030 0x00
    iomuxc_set_reg 0x034 0x00
    iomuxc_set_reg 0x038 0x00
    iomuxc_set_reg 0x03C 0x00
    iomuxc_set_reg 0x040 0x00
    iomuxc_set_reg 0x044 0x00
    iomuxc_set_reg 0x048 0x00
    iomuxc_set_reg 0x04C 0x00
    iomuxc_set_reg 0x050 0x00
    iomuxc_set_reg 0x054 0x00
    iomuxc_set_reg 0x058 0x00
    iomuxc_set_reg 0x05C 0x00
    iomuxc_set_reg 0x060 0x00
    iomuxc_set_reg 0x064 0x00
    iomuxc_set_reg 0x068 0x00
    iomuxc_set_reg 0x06C 0x00
    iomuxc_set_reg 0x070 0x00
    iomuxc_set_reg 0x074 0x00
    iomuxc_set_reg 0x078 0x00
    iomuxc_set_reg 0x07C 0x00
    # GPIO_EMC_B1_28 -> SEMC_WEC
    iomuxc_set_reg 0x080 0x00
    iomuxc_set_reg 0x084 0x00
    iomuxc_set_reg 0x088 0x00
    iomuxc_set_reg 0x08C 0x00
    iomuxc_set_reg 0x090 0x00
    iomuxc_set_reg 0x094 0x00
    iomuxc_set_reg 0x098 0x00
    iomuxc_set_reg 0x09C 0x00
    iomuxc_set_reg 0x0A0 0x00
    iomuxc_set_reg 0x0A4 0x00
    iomuxc_set_reg 0x0A8 0x00
    # SEMC_DQS, En SION
    iomuxc_set_reg 0x0AC 0x10
    iomuxc_set_reg 0x0B0 0x00
    iomuxc_set_reg 0x0B4 0x00
    iomuxc_set_reg 0x0B8 0x00
    iomuxc_set_reg 0x0BC 0x00
    iomuxc_set_reg 0x0C0 0x00
    iomuxc_set_reg 0x0C4 0x00
    iomuxc_set_reg 0x0C8 0x00
    iomuxc_set_reg 0x0CC 0x00
    iomuxc_set_reg 0x0D0 0x00
    iomuxc_set_reg 0x0D4 0x00
    iomuxc_set_reg 0x0D8 0x00
    iomuxc_set_reg 0x0DC 0x00
    iomuxc_set_reg 0x0E0 0x00
    iomuxc_set_reg 0x0E4 0x00
    iomuxc_set_reg 0x0E8 0x00
    iomuxc_set_reg 0x0EC 0x00
    iomuxc_set_reg 0x0F0 0x00
    iomuxc_set_reg 0x0F4 0x00
    iomuxc_set_reg 0x0F8 0x00
    iomuxc_set_reg 0x0FC 0x00
    # SEMC_DQS4
    iomuxc_set_reg 0x100 0x00
    # SEMC_CLKX00
    iomuxc_set_reg 0x104 0x00
    # SEMC_CLKX01
    iomuxc_set_reg 0x108 0x00
}

proc semc_iomuxc_pad {} {
    # PAD ctrl
    # PDRV = 1b (normal); PULL = 10b (PD)
    iomuxc_set_reg 0x254 0x08
    iomuxc_set_reg 0x258 0x08
    iomuxc_set_reg 0x25C 0x08
    iomuxc_set_reg 0x260 0x08
    iomuxc_set_reg 0x264 0x08
    iomuxc_set_reg 0x268 0x08
    iomuxc_set_reg 0x26C 0x08
    iomuxc_set_reg 0x270 0x08
    iomuxc_set_reg 0x274 0x08
    iomuxc_set_reg 0x278 0x08
    iomuxc_set_reg 0x27C 0x08
    iomuxc_set_reg 0x280 0x08
    iomuxc_set_reg 0x284 0x08
    iomuxc_set_reg 0x288 0x08
    iomuxc_set_reg 0x28C 0x08
    iomuxc_set_reg 0x290 0x08
    iomuxc_set_reg 0x294 0x08
    iomuxc_set_reg 0x298 0x08
    iomuxc_set_reg 0x29C 0x08
    iomuxc_set_reg 0x2A0 0x08
    iomuxc_set_reg 0x2A4 0x08
    iomuxc_set_reg 0x2A8 0x08
    iomuxc_set_reg 0x2AC 0x08
    iomuxc_set_reg 0x2B0 0x08
    iomuxc_set_reg 0x2B4 0x08
    iomuxc_set_reg 0x2B8 0x08
    iomuxc_set_reg 0x2BC 0x08
    iomuxc_set_reg 0x2C0 0x08
    iomuxc_set_reg 0x2C4 0x08
    iomuxc_set_reg 0x2C8 0x08
    iomuxc_set_reg 0x2CC 0x08
    iomuxc_set_reg 0x2D0 0x08
    iomuxc_set_reg 0x2D4 0x08
    iomuxc_set_reg 0x2D8 0x08
    iomuxc_set_reg 0x2DC 0x08
    iomuxc_set_reg 0x2E0 0x08
    iomuxc_set_reg 0x2E4 0x08
    iomuxc_set_reg 0x2E8 0x08
    iomuxc_set_reg 0x2EC 0x08
    iomuxc_set_reg 0x2F0 0x08
    iomuxc_set_reg 0x2F4 0x08
    iomuxc_set_reg 0x2F8 0x08
    iomuxc_set_reg 0x2FC 0x08
    iomuxc_set_reg 0x300 0x08
    iomuxc_set_reg 0x304 0x08
    iomuxc_set_reg 0x308 0x08
    iomuxc_set_reg 0x30C 0x08
    iomuxc_set_reg 0x310 0x08
    iomuxc_set_reg 0x314 0x08
    iomuxc_set_reg 0x318 0x08
    iomuxc_set_reg 0x31C 0x08
    iomuxc_set_reg 0x320 0x08
    iomuxc_set_reg 0x324 0x08
    iomuxc_set_reg 0x328 0x08
    iomuxc_set_reg 0x32C 0x08
    iomuxc_set_reg 0x330 0x08
    iomuxc_set_reg 0x334 0x08
    iomuxc_set_reg 0x338 0x08
    iomuxc_set_reg 0x33C 0x08
    iomuxc_set_reg 0x400 0x08
    iomuxc_set_reg 0x404 0x08
    iomuxc_set_reg 0x408 0x08
    iomuxc_set_reg 0x40C 0x08

    echo "Info : semc_iomuxc_pad."
}


proc semc_regs_setup {} {
    # Config SDR Controller Registers/
    # MCR
    mww 0x400d4000 0x10000004
    # BMCR0
    mww 0x400d4008 0x00030524
    # BMCR1
    mww 0x400d400C 0x06030524
    # BR0, 64MB
    mww 0x400d4010 0x8000001D
    # SDRAMCR0, 32bit
    mww 0x400d4040 0x00000F32
    # SDRAMCR1
    mww 0x400d4044 0x00772A22
    # SDRAMCR2
    mww 0x400d4048 0x00010A0D
    # SDRAMCR3
    mww 0x400d404C 0x21210408
    # IPCR0
    mww 0x400d4090 0x80000000
    # IPCR1
    mww 0x400d4094 0x00000002
    # IPCR2
    mww 0x400d4098 0x00000000
    # IPCMD, SD_CC_IPREA
    mww 0x400d409C 0xA55A000F
    semc_wait_ipcmddone
    # SD_CC_IAF
    mww 0x400d409C 0xA55A000C
    semc_wait_ipcmddone
    # SD_CC_IAF
    mww 0x400d409C 0xA55A000C
    semc_wait_ipcmddone
    # IPTXDAT
    mww 0x400d40A0 0x00000033
    # SD_CC_IMS
    mww 0x400d409C 0xA55A000A
    semc_wait_ipcmddone
    # enable sdram self refresh after initialization done.
    mww 0x400d404C 0x21210409

    echo "Info : semc_regs_setup."
}


proc init_sys_pll2_pfd1 {} {
  # ANADIG_PLL_PLL_528_PFD
  mem2array reg 32 0x40C84270 1
  if { [expr $reg(0) & 0x8000] != 0 || [expr ($reg(0) & 0x3F00) >> 8] != 33 } {
    set STABLE  [expr $reg(0) & 0x4000]
    # clock-gate (power-off)
    set REG [expr $reg(0) | 0x8000]
    mww 0x40C84270 $REG

    mem2array reg 32 0x40C84270 1
    set REG [expr $reg(0) & ~0x3F00]
    # set pfd1_FRAC
    set REG [expr $REG | (33 << 8)]
    mww 0x40C84270 $REG

    mem2array reg 32 0x40C84250 1
    set REG [expr $reg(0) ^ 0x04]
    mww 0x40C84250 $REG

    mem2array reg 32 0x40C84270 1
    # power-on
    set REG [expr $REG & ~0x8000]
    mww 0x40C84270 $REG

    mem2array reg 32 0x40C84270 1
    while { [expr $reg(0) & 0x4000] == $STABLE} {
        mem2array reg 32 0x40C84270 1
    }
  } else {
    echo "syspll2 pfd1 already initialized"
    set REG [expr $reg(0) & ~0x8000]
    mww 0x40C84270 $REG
  }

  echo "Info : init_sys_pll2_pfd1 done."
}


proc init_sys_pll2_pfd3 {} {
  # ANADIG_PLL_PLL_528_PFD
  mem2array reg 32 0x40C84270 1
  if { [expr $reg(0) & 0x80000000] != 0 || [expr ($reg(0) & 0x3F000000) >> 24] != 33 } {
    set STABLE  [expr $reg(0) & 0x40000000]
    # clock-gate (power-off)
    set REG [expr $reg(0) | 0x80000000]
    mww 0x40C84270 $REG

    mem2array reg 32 0x40C84270 1
    set REG [expr $reg(0) & ~0x3F00]
    # set pfd3_FRAC
    set REG [expr $REG | (33 << 24)]
    mww 0x40C84270 $REG

    mem2array reg 32 0x40C84250 1
    set REG [expr $reg(0) ^ 0x04]
    mww 0x40C84250 $REG

    mem2array reg 32 0x40C84270 1
    # power-on
    set REG [expr $REG & ~0x80000000]
    mww 0x40C84270 $REG

    mem2array reg 32 0x40C84270 1
    while { [expr $reg(0) & 0x40000000] == $STABLE} {
        mem2array reg 32 0x40C84270 1
    }
  } else {
    echo "syspll2 pfd3 already initialized."
    set REG [expr $reg(0) & ~0x8000]
    mww 0x40C84270 $REG
  }
  echo "Info : init_sys_pll2_pfd1 done."
}


proc clock_source_control {name value} {
    # CCM : Clock Control Module (40CC_0000h)
    set CCM_BASE    0x40cc0000
    set CCM_OSCPLL_DIRECT  [expr $CCM_BASE + (0x5000 + $name * 0x20)]
    mww $CCM_OSCPLL_DIRECT $value
}

proc clock_gate_control {name value} {
    # CCM : Clock Control Module (40CC_0000h)
    set CCM_BASE    0x40cc0000
    set CCM_LPCG_DIRECT  [expr $CCM_BASE + (0x6000 + $name * 0x20)]
    mww $CCM_LPCG_DIRECT $value
}

proc clock_source_enable {name} {
    # pg1434
    clock_source_control $name 1
}

proc clock_gate_enable {name} {
    # pg1434
    clock_gate_control $name 1
}


proc clock_gate_disable {name} {
    # pg1434
    clock_gate_control $name [expr ~1]
}

proc root_clock_authen_set {root val} {
    set  CCM_BASE    0x40cc0000
    set  CCM_CLOCK_ROOT_AUTHEN_SET [expr $CCM_BASE + (0x34 + $root*0x80)]
    mww $CCM_CLOCK_ROOT_AUTHEN_SET $val
}

proc root_clock_mux {root src} {
    set  CCM_BASE    0x40cc0000
    set  CCM_CLOCK_ROOT_CONTROL_MUX_SHIFT 8
    set  CCM_CLOCK_ROOT_CONTROL [expr $CCM_BASE + (0x0 + $root*0x80)]
    mww $CCM_CLOCK_ROOT_CONTROL [expr $src << $CCM_CLOCK_ROOT_CONTROL_MUX_SHIFT]
}

proc root_clock_clr {root} {
    set  CCM_BASE    0x40cc0000
    set  CCM_CLOCK_ROOT_CONTROL_CLR  [expr $CCM_BASE + (0x8 + $root*0x80)]
    mww $CCM_CLOCK_ROOT_CONTROL_CLR  0xFFFF
}

proc root_clock_div {root div} {
    set  CCM_BASE    0x40cc0000
    set  CCM_CLOCK_ROOT_CONTROL_DIV_SHIFT 0x0
    set  CCM_CLOCK_ROOT_CONTROL_SET  [expr $CCM_BASE + (0x4 + $root*0x80)]
    mww $CCM_CLOCK_ROOT_CONTROL_SET  [expr ($div - 1) << $CCM_CLOCK_ROOT_CONTROL_DIV_SHIFT]
}

# PLL output frequency = Fref*(MFI + MFN/MFD))
proc root_clock_mfn_mfd {root mfn mfd} {
    set  CCM_BASE    0x40cc0000
    set  CCM_CLOCK_ROOT_CONTROL_SET  [expr $CCM_BASE + (0x4 + $root*0x80)]
    mww $CCM_CLOCK_ROOT_CONTROL_SET  [expr ($mfn << 20) | ($mfd << 16)]
}

proc iomuxc_set_reg {offset value} {
    set IOMUXC_BASE_ADDRESS             0x400E8000
    set address [expr $IOMUXC_BASE_ADDRESS + $offset]
    mww $address $value
}


proc iomuxc_sw_mux_ctl_pad_sion {x} {
    set iomuxc_sw_mux_ctl_pad_sion_SHIFT    0x04
    set iomuxc_sw_mux_ctl_pad_sion_MASK     0x10
    return [expr  ($x << $iomuxc_sw_mux_ctl_pad_sion_SHIFT) & $iomuxc_sw_mux_ctl_pad_sion_MASK]
}


proc iomuxc_sw_mux_ctl_pad_mux_mode {x} {
    set iomuxc_sw_mux_ctl_pad_mux_mode_SHIFT 0x00
    set iomuxc_sw_mux_ctl_pad_mux_mode_MASK  0x0F
    return [expr ($x << $iomuxc_sw_mux_ctl_pad_mux_mode_SHIFT) & $iomuxc_sw_mux_ctl_pad_mux_mode_MASK]
}


proc iomuxc_pad_mux {padRegister muxMode inputOnfield} {
    set SION_MODE      [iomuxc_sw_mux_ctl_pad_sion     $inputOnfield]
    set MUX_MODE       [iomuxc_sw_mux_ctl_pad_mux_mode $muxMode]
    iomuxc_set_reg $padRegister   [expr $SION_MODE | $MUX_MODE ]
}


proc iomuxc_pad_config {configRegister configValue} {
    iomuxc_set_reg $configRegister $configValue
}


proc iomuxc_lpsr_get_reg {offset} {
    set IOMUXC_LPSR_BASE_ADDRESS        0x40C08000
    set address [expr $IOMUXC_LPSR_BASE_ADDRESS + $offset]
    mem2array value 32 $address 1
    echo [format "get *0x%X = 0x%X" $address $value(0)]
}
proc iomuxc_lpsr_set_reg {offset value} {
    set IOMUXC_LPSR_BASE_ADDRESS        0x40C08000
    set address [expr $IOMUXC_LPSR_BASE_ADDRESS + $offset]
    mww $address $value
    echo [format "set *0x%X = 0x%X" $address $value]
}


proc iomuxc_lpsr_set_pin_mux {padRegister muxMode forceInput} {
    set SION_MODE      [iomuxc_sw_mux_ctl_pad_sion     $forceInput]
    set MUX_MODE       [iomuxc_sw_mux_ctl_pad_mux_mode $muxMode]
    iomuxc_lpsr_get_reg $padRegister
    iomuxc_lpsr_set_reg $padRegister   [expr $SION_MODE | $MUX_MODE ]
}

proc iomuxc_lpsr_set_pin_config {configRegister configValue} {
    iomuxc_lpsr_get_reg $configRegister
    iomuxc_lpsr_set_reg $configRegister $configValue
}

# pg344  GPIO_LPSR_11 (OUTPUT) (TRACESWO)
proc setup_gpio_lpsr_11 {SW_PAD_CTL altMode} {
    echo "setup_gpio_lpsr_11"

    set  SW_MUX_CTL_PAD_GPIO_LPSR_11  0x02c
    iomuxc_lpsr_set_pin_mux    $SW_MUX_CTL_PAD_GPIO_LPSR_11 $altMode 0x00

    set  SW_PAD_CTL_PAD_GPIO_LPSR_11  0x06c
    iomuxc_lpsr_set_pin_config $SW_PAD_CTL_PAD_GPIO_LPSR_11 $SW_PAD_CTL

    echo "setup_gpio_lpsr_11 done"
}

# (OUTPUT) (TRACECLK)
# JTAG_MUX_TCK - GPIO_LPSR_14
# ARM_TRACE_CLK - GPIO_DISP_B2_06
proc arm_trace_clk_setup {} {
    set              SW_MUX_CTL_PAD_GPIO_DISP_B2_06 0x22C
    iomuxc_set_reg  $SW_MUX_CTL_PAD_GPIO_DISP_B2_06 0x03

    set              SW_PAD_CTL_PAD_GPIO_DISP_B2_06 0x470
    iomuxc_set_reg  $SW_PAD_CTL_PAD_GPIO_DISP_B2_06 0x06
}

proc arm_trace_swo_setup {} {
    set              SW_MUX_CTL_PAD_GPIO_DISP_B2_07 0x230
    iomuxc_set_reg  $SW_MUX_CTL_PAD_GPIO_DISP_B2_07 0x03

    set              SW_PAD_CTL_PAD_GPIO_DISP_B2_07 0x474
    iomuxc_set_reg  $SW_PAD_CTL_PAD_GPIO_DISP_B2_07 0x06
}

proc LPCG {nb} {
    return $nb
}
proc CLOCK_ROOT {nb} {
    return $nb
}
proc SW_MUX_ALT {nb} {
    return $nb
}
proc swo_iomuxc_mux {} {
    # Slew Rate          : 0b - Slow                 1b - Fast*
    set SW_PAD_SRE  [expr 1 & 0x01]

    # Drive Strength     : 0b - Normal               1b - High
    set SW_PAD_DSE  [expr 1 & 0x01]

    # Pull / Keep Select : 0b - Pull Disable, Highz  1b - Pull Enable
    set SW_PAD_PUE  [expr 1 & 0x01]

    # Pull Up / Down     : 0b - Weak pull down       1b - Weak pull up
    set SW_PAD_PUS  [expr 1 & 0x01]

    # rt1064: 0xF9 b11111001: speed_3_max_200MHz,dse_7_r0_7, fast slew,
    # pg236-refman (pg128-datasheet): TDO is HighZ
    set SW_PAD_CTL  [expr ($SW_PAD_PUS << 3) | ($SW_PAD_PUE << 2) | ($SW_PAD_DSE << 1) | ($SW_PAD_SRE)]

    # pg345
    #       Port           Pad              Mode
    #       JTAG_MUX_TDO   GPIO_LPSR_11     ALT0
    #       ARM_TRACE_SWO  GPIO_LPSR_11     ALT7
    #       ARM_TRACE_SWO  GPIO_DISP_B2_07  ALT3
    #       ARM_TRACE0     GPIO_DISP_B2_02  ALT3
    #       ARM_TRACE_CLK  GPIO_DISP_B2_06  ALT3

    setup_gpio_lpsr_11  $SW_PAD_CTL [SW_MUX_ALT 7]

    echo "Info : swo_iomuxc_mux done."
}

# 1. The speed of the external interface is from TRACECLKIN (TRACE_CLK_ROOT),
# and should be selectable via an on-chip or off-chip clock.
# 2. TRACECLK (ARM_TRACE_CLK) is equal to TRACECLKIN / 2,
# and is divided inside the TPIU in order to clock the trace data at the
# Trace Capture Unit.
# 3. Set SWO baud rate to Hz to match TPIU_clk/(tpiu.TPIU_ACPR+1)
# (528.000.000/572)/104
# 4. The probe must be able to set a UART speed to within
# 3% of the SWO's baud rate.
# prescaler=104

# TRACECLKIN or TRACE_CLK_ROOT or trace_clk_root

# SYS_PLL2_PFD1    has OSCPLL11 as control register, pg1361
# cstrace_clk_root has CLOCK_ROOT6 as control register, pg1364.
# LPCG42           is gate-controlling trace_clk_root, pg1383
# PLL2 is 528MHz, trace_clk_root runs at  528MHz/6=88MHz
proc cstrace_clk_root_setup {} {
    set SYS_PLL3_DIV2    4

    root_clock_mux [CLOCK_ROOT 6]  $SYS_PLL3_DIV2
    root_clock_div [CLOCK_ROOT 6]  4

    echo "Info : cstrace_clk_root_setup done"
}


proc init_board {} {
    global _TARGETNAME
    $_TARGETNAME configure -event reset-end {
        setup_vec
        clear_pending_irq

        # iomuxc
        clock_gate_enable [LPCG 49]

        # iomuxc lpsr
        clock_gate_enable [LPCG 50]

        semc_iomuxc_mux
        semc_iomuxc_pad
        semc_clk_root_setup
        semc_regs_setup

        # cstrace and cssys
        clock_gate_enable [LPCG 41]
        clock_gate_enable [LPCG 42]

        swo_iomuxc_mux

        arm_trace_swo_setup
        arm_trace_clk_setup

        cstrace_clk_root_setup

        # enable cs-SWO
        mww 0xe0048fb0  0xC5ACCE55

        # SWO-divisor CODR
        mww 0xe0048010  0x8

        # selected pin protocol
        mww 0xe00480f0  0x2

        # enable tsgen - no effect on swo output
        mww 0xe0047000  0x1

        # enable cstf
        mww 0xE0045FB0  0xC5ACCE55
        mww 0xE0045000  0x0f

        # enable m7-funnel
        mww 0xE0043fb0  0xC5ACCE55
        mww 0xE0043000  0x0f

        # test memory read on SWO register
        mem2array reg 32 0xE0048FC8 1
        echo $reg(0)
        tpiu create imxrt1170.tpiu -dap imxrt1170.dap -ap-num 0 -baseaddr 0xE0046000
        swo  create imxrt1170.swo  -dap imxrt1170.dap -ap-num 0 -baseaddr 0xE0048000
        imxrt1170.swo configure -protocol uart -traceclk 100000000 -pin-freq 100000 -output 1170-out.txt
        imxrt1170.cm7 itm ports on
        imxrt1170.swo enable
    }
    $::_TARGETNAME configure -event examine-end {
        cortex_m reset_config vectreset
    }
}
